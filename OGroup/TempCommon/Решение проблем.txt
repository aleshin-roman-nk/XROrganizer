>>> 30-06-2021 13:37
Лучше общение модулей явно. через хаб - наблюдатель.
неявные подписки к репозиториям ухудшают понимание работы модулей.
Bus _bus = new Bus();

_bus.Host = _directoryService;
_bus.AddChild(_filesService);

а еще лучше взаимодействие между презентерами а не сервисами. более прозрачное строение. все связи осуществляются на верхнем уровне.

интерфейс конкретного сервиса набирать из функциональных интерфейсов.
например сервис должен поддерживать систему сообщение.
Вернее презентер, не сервис, для системы сообщений.

>>> 29-06-2021 20:03
Может быть таблица презентеров.
Адреса. Посылка сообщения по адресу. Или таблица сервисов. Но все должны подчинятся протоколу.


>>> 29-06-2021 15:31
fileService.Observe(dirService);
В общем в пределах одного проекта необходимо утвердить протокол кто где отвечает.
А если архитектура эффективная, принять за правило при импользовании mvp.




>>> 27-06-2021 23:51
Может отдельная мьюшка это панель кнопок.
Главная морда может посмотреть текущий элемент в подморде и создать событие.

А может быть какая то шина команд. Мордочки подписываются. Нажатие кнопки просто посылает команду на шину.
commandHub

subview:
commandHub.Command += (cmdName);

btnSaveFile_Click:
commandHub.Publish(UserCommand.SaveFile);

Но в данном случае я хочу оставить кнопки в компоненте.


>>> 26-06-2021 23:14
!!! Окончательно - промежуточное решение.
Окно директорий.
Окно файлов директории. Заметки, задачи и др. что принадлежит директории кроме других директорий.


>>> 26-06-2021 01:27
presenter = new presenter(service, view); - и никаких вариантов! Подчинять протоколу, общей логике. Все однотипно.
Если надо, чтобы сервисы между собой общались (или презентеры) нужно делать это через некий домен, хаб.
на уровне коммуникаций модулей необходим общий протокол.


>>> 17-06-2021 10:03
Я же могу сделать универсальным хост сервис. Репозиторий, который дает методы
GetByParent(INode)

Такой репозиторий может опрашивать другие репозитории, если нужно в одну грид положить разнотипные сущности.


>>> 17-06-2021 01:23
Новая идея сущности в xorg хронолог. То есть запись идей проекта. Как здесь.
То есть открываю сущнось хронолога, открывается окно хронолога, и пишу туда лог рассуждений. Классная идея.

>>> 17-06-2021 00:10
Либо разные таблицы, объекты ссылаются знают на какой конкретно тип.
Либо одна таблица, в пределах которой разные типы ссылаются на владельца.
Интерфейс может использоваться только для возможности выводить объекты разного типа в одну таблицу.
Но загружаются они разными репозиториями. А затем общий репозиторий собирает все в кучу и отдает морде.
То есть общий репо (или это сервис) опрашивает репозитории, то, что может относится к одной системе. Например директории, задачи, заметки, какие то марафоны... Сессии не относятся к этой системе. Сессии подчинены задаче. Сервис статистики берет директорию, и опрашивает репозиторий задач, какие задачи, затем репозиторий сессий. И считает нужную нам статистику.

Если одна таблица, вариант кода сборки:
TaskNode = builder.TaskNode.Create(INode, TaskNodePart);

В любом случае, директории останутся отдельно, или одна таблица, задача выводить в одной таблице разнотипные объекты должна быть решена. Так как не только заметки диркторий я должен выводить в гриде заметок, но и задачи и разные объекты, которы содержит данная директория.

Сессии идут только к задаче какой то. Пусть по умолчанию. Хотя owner_type позволяет подвешивать и напрямую к дирктории.

Получается и интерфейсом нужно объединять только те классы сущностей, которые идут в одной системе.
Но в нашем случае, директории, задачи, заметки, сессии...

Довести до ума механизм навигатор - репозиторий (сервис). Принять окончательное решение как.
Service.Repo = repo;// -> вообще репо не меняется во время работы. Поэтому надо в конструкторе сразу устанавливать репо.
Service.Navigator.Action();
ServiceA.SetHost(Service);
	Service.MasterObjectChanged += method(){};
event ServiceA.CollectionChanged;

>>> 16-06-2021 19:25
Интерфейс морды (части морды) имеет метод DisplayData(T d)
гду Т - тип объекта, с которым работает морда.
Это может быть коллекция, или объект.

>>> 16-06-2021 19:20
public class DirectoryHostService : IDirectoryHostService...
private IEnumerable<INode> select(INode own)
{
    List<INode> res = new List<INode>();
    if (own.type != NType._sys_root_dir)
        res.Add(TopExitNode.Value);

    res.AddRange(_repo.SelectByOwner(own));

    return res;
}
Здесь нужно уточнить данные. Это не тот модуль, который работает с разнотипными данными.

>>> 16-06-2021 19:17
Репозиторий предоставляет нобор методов получения данных из источников.
Сервис содержит различную логику преобразования данных.

>>> 16-06-2021 13:32
Всетаки ведущий репо внедрить в Navigator. Так как я хочу быть уверенным что навигатор получает объект из наблюдаемой коллекции.
А репозиторий просто поддерживает стандартный набор методов репозитория, который отдает сущности по владельцу.
То есть такой репозиторий реализует два интерфейса, обычный репо, и репо который имеет метод GetBranch(INode owner)

Мне кажется, сервис наблюдатель за навигатором сделать как не сервис под конкретный репозиторий, а как перемычку, которую удобно использовать для других сервисов.

>>> 15-06-2021 23:59
Код:
public interface IDirectoryRepository: IRepository<Dir>
{
	IEnumerable<INode> SelectByOwner(int owner_id);
}
Не мудрить, а писать типизированный метод, где владелец - конкретный тип, например Dir.
Ведь репозиторий типизированный.
====================================================
Добавить модуль абстьрактного месячного матрицу-расписания.

>>> 15-06-2021 12:24
Работа с данными (репозиториями) через сервисы гибче.


>>> 15-06-2021 11:47
Обеспечить разные типы сущностей. В том числе тип сервиса который работает с кучей разных типов и одной таблицей.
Маршрутизатор поступающих сущностей.

>>> 15-06-2021 11:19
Вопрос сейчас: как создать и присоединить сущность к владельцу.


>>> 15-06-2021 10:25
Репозиторий - это репозиторий. Он только работает с извлечением, сохранением сущностей.
Всегда одна цепочка:

Репо - Сервис - Презентер (потребитель)
Нет, не всегда. Можем просто хотеть брать данные.
Но всегда подписываемся на событие изменения данных в репо.
    Тогда сервис будет отвечать за текущую картину параметров образа данных.
        Если это необходимо (образ параметров выборки) тогда через сервис.
            Либо тип (определенный через интерфейс) репо, собержащий композитом образ.

>>> 15-06-2021 09:12
1.
IRepository
GetByOwner(INode owner)
Репозитории этого проекта имеют обязательный метод GetByOwner
А репозитории расширений иноформации 

2.
Node: INode
Дополнительная информация располагается в дополнительных таблица.
Сущность не знает о дополнительной информации.
Репозитории ответствены за дополнительную информацию.


!!!!!!!!!!!!!
событие изменения коллекции в репозитории должно говорить что что то добавилось, удалилось, но не текущий список.
изменение текущего списка, хост сущности - это уже сервис.
Почему такое решение лучше? Потому что я хочу иметь возможность собирать сервисы. Один сервис - хост, другой обычный, но оба следят за одним репозиторием на изменения состояния базы данных.
!!!! Можно было бьы вариант отнаследоваться от обычного репо.
simpleRepo;
HostRepo = simpleRepo + navigator;
simpleRepo.Host = HostRepo.Navigator;
======================

>>> 14-06-2021 00:19
Задача: объекты root, top_exit как часть коллекции Dir. Использование объекта - константы.



repo.Navigator.Enter(INode);
repo.Navigator.JumpBack();

otherRepo.Host = repo.Navigator;





>>> 13-06-2021 13:58
!!!!! Может правда не репо подписывается на мастера а сервис управляет репо связавшись с мастером.

>>> 12-06-2021 00:13
репо следит за текущим элементом другого репо.
репо отдает коллекцию.
репо оповещает, что коллекция изменилась.
репо сохраняет AttachAndSave
dirRepo.AttachAndSave(task);

мастер-репо подписан на сервис изменения элементов.
сервис изменения принимает репо, по элементам которого он навигацию делает.
это специальный дерево-репо.

задача - написать класс - мастер, на который будут подписываться другие репо и выдавать коллекции по изменению текущего узла в классе - мастере. Или такая архитектура:
master_observer <- repo_dir
repo_dir <- repo_notes
repo_dir <- repo_task
...

то есть цепочка репозиториев, зависимых от других.
таким образом каждый репо наследует интерфейс
CurrentNodeChanged<INode>


==========================

/*
 * >>> 10-06-2021 01:16
 * taskRepo.Master = dirRepo;
 * taskPresenter.View = mainView.taskView;
 * taskPresenter.Service = taskRepo;
 * 
 * 
 * ...
 * 
 * dirRepo.Update();
 * 
 * 
 * 
 */

==========================
Событие изменения текущей картины.
Без параметров. По событию обращаемся к экземпляру и читаем поля.
С параметром. В событие передается аргумент - образ данных модуля.
==========================

dirRepo = new();
taskRepo = new();
taskRepo.SetMaster(dirRepo);

view.Dirs.EnterDir += (x)=>{
dirRepo.Enter();
}

taskRepo.CollectionChanged += {
	view.TaskGrid.Display(taskRepo.Items);
}

// >>> 10-06-2021 23:24
// Определение правила
// какие то хитрые вычисления в сервисе
// логика выборки, сохранений, удалений - в репозитории
taskService = new();
taskService.Repo = taskRepo;


naviView
naviService <> repo
to interact through the interface, we need to know which element is the current one.

IMainView: ICRUDComponent<EntityA>

RepoA: IRepository<EntityA>

intrface IRepository
{
	

}

class DirService
{
	public DirService(IDirRepo repo)
	
}

>>> 06-06-2021 18:17
!!!!!!!!!!!!!!!!!!
ОДНА МОРДА - ОДИН КОНТРОЛЛЕР МОРДЫ - ОДИН СЕРВИС
эти троицы упаковывать в презентеры.
В данном случае, если коллекция задач зависит от текущей директории, лучше решить это через подписку к событию выбора текущей директории.

NodesNavigatorService
in IDirectoryRepository dirRepo
+ Update()
+ event <NodesNavigatorImage> CurrentNodeChanged
+ EnterDir()
+ JumpBack()

DirNavigatorView
+ event EventHandler<INode> ActivateNode;
+ event EventHandler ExitNode;
+ void SetDirImage(NodesNavigatorImage dataImage);



(presenter - client)
DirNavigatorView ActivateNode / ExitNode
-> NodesNavigatorService EnterDir() / JumpBack() -> CurrentNodeChanged

IDirectoryRepository CreateDir(int ownerId, string dirName)
NodesNavigatorService Update() -> CurrentNodeChanged

====== (PresenterServices)
DirNaviPresenter
< IDirectoryRepository
< NodesNavigatorService
< DirNavigatorView



